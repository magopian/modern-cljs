# Tutorial 3 - House Keeping

In the [previous tutorial][1] we started approaching the Immediate
Feedback Principle by Bret Victor by using the `boot` building tool
and piping few additional tasks developed by the community:

* `boot-cljs`: to compile CLJS source code (introduced in
  [Tutorial-01][2]);
* `boot-http`: to run a CLJ based web server to serve pages;
* `boot-reload`: to reload static resources when changes are saved;
* `boot-cljs-repl`: to connect a CLJS REPL to the JS engine of the
  browser (bREPL).

In this tutorial we're going to improve the developer interaction with
the `boot` building tool by minimizing the length of the `boot`
commands to be submitted to the terminal, while supporting the immediate
feedback style of programming.

## Preamble

If you want to start working from the end of the [previous tutorial][1],
assuming you've `git` installed, do as follows.

```bash
git clone https://github.com/magomimmo/modern-cljs.git
cd modern-cljs
git checkout tutorial-03
git checkout -b tutorial-03-step-1
```

This way you're cloning the `tutorial-02` branch into a new branch to
start working with.

## Introduction

Let's start reviewing the `boot` commands we previously submitted to
the terminal to progressively approach the Immediate Feedback
Principle.

### CLJS compilation

First, in [Tutorial-01][2] we configured a few environment
variables. Namely `:source-paths` and `:resource-paths`.

Then we launched the CLJS compilation with the following very simple
`boot` command:

```bash
boot cljs
```

We did not pass any compilation option to the task by exploiting a few
available defaults. Namely:

* `none` as compiler optimizations;
* `main.js` as name of JS file generated by the compiler
* `"target"` as name of the directory under which `main.js` is
  saved.

### HTTP server

In [Tutorial-02][1] we started adding the `serve` task to the pipe. We
passed it the `-d target` option to instruct the task about the main
directory to serve. They could have the same `target` default as they
did for `cljs`, but they did not. So we needed to be specific.

As you could remember, we also needed to interpose in the pipeline the
`wait` task between the `serve` and `cljs` tasks.

```bash
boot serve -d target wait cljs
```

### CLJS recompilation

To trigger the CLJS recompilation when we modify and save a CLJS
source file, we added the predefined `watch` task by positioning it
immediatley before the `cljs` task itself.

```bash
boot serve -d target wait watch cljs
```

### boot-reload

Again, to trigger the reloading of static resources when we save their
changes or changes in the CLJS source code they link, we added the
`reload` task to the pipeline before the `cljs` task.

```bash
boot serve -d target wait watch reload cljs
```

### bREPL

Last, but not least, to almost complete our intent of approaching the
Immediate Feedback Principle by offering a browser base REPL (bREPL),
we had to add at the end of the pipeline the `cljs-repl` task.

```bash
boot serve -d target wait watch reload cljs cljs-repl
```

If you complain about the things you have to remember just to start
playing around your project, you're right.

This is why `boot` core developers offer you a very comfortable way to
help your typing and your memory.

## Enter deftask

From the user point of view, one of the interesting aspects of `boot` is
the composable nature of its tasks, whether predefined by `boot` or
not. You could spend days in studying `boot` source code to better
unserstand its architecture, but we want to be pragmatic. At the
moment we are only interested in reducing the need of memorizing task
names and order while launching the `boot` command.

All we have to do is to open the `build.boot` and define new tasks as
an ordered composition of other tasks by using the `deftask` macro as
follows:

```clj
(set-env!
 :source-paths #{"src/cljs"}
 :resource-paths #{"html"}
 
 :dependencies '[[org.clojure/clojure "1.7.0"]
                 [org.clojure/clojurescript "1.7.122"]
                 [adzerk/boot-cljs "1.7.48-6"]
                 [pandeiro/boot-http "0.6.3"]
                 [adzerk/boot-reload "0.4.1"]
                 [adzerk/boot-cljs-repl "0.2.0"]])

(require '[adzerk.boot-cljs :refer [cljs]]
         '[pandeiro.boot-http :refer [serve]]
         '[adzerk.boot-reload :refer [reload]]
         '[adzerk.boot-cljs-repl :refer [cljs-repl start-repl]])

;; add the dev composite task
(deftask dev
  "Launch Immediate Feedback Development Environment"
  []
  (comp 
   (serve :dir "target")
   (wait)
   (watch)
   (reload)
   (cljs)
   (cljs-repl)))
```

First you should note the use of the `comp` function in the body of the
newly created `dev`. If you do not know CLJ [`transducers`][3] you
could be surprised by observing the order of the tasks passed to the
`comp` function to compose the `dev` task itself. If, instead, you
know `trasducers` you're not surprised at all by that order, which
is the same you saw before in the terminal window when we called the
`boot` command.

## Next step - [Tutorial 4: Modern ClojureScript][4]

In the [next tutorial 4][4] we're going to have some fun introducing form validation in CLJS.

# License

Copyright Â© Mimmo Cosenza, 2012-2014. Released under the Eclipse Public
License, the same as Clojure.

[1]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-02.md
[2]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-01.md
[3]: http://clojure.org/transducers
[4]: https://github.com/magomimmo/modern-cljs/blob/master/doc/tutorial-04.md
